DECL|Ctxt|member|K_CREF Ctxt;
DECL|K_ARGS_ARGS|typedef|typedef union k_args_args K_ARGS_ARGS;
DECL|K_CREF|typedef|} K_CREF;
DECL|MVDACT_INVALID|macro|MVDACT_INVALID
DECL|MVDACT_NONE|macro|MVDACT_NONE
DECL|MVDACT_RCVACK|macro|MVDACT_RCVACK
DECL|MVDACT_ROR_RCV|macro|MVDACT_ROR_RCV
DECL|MVDACT_ROS_SND|macro|MVDACT_ROS_SND
DECL|MVDACT_SNDACK|macro|MVDACT_SNDACK
DECL|MVDACT_VALID|macro|MVDACT_VALID
DECL|MovedAction|typedef|typedef uint32_t MovedAction;
DECL|PIPE_REQUEST_STATUS|typedef|} PIPE_REQUEST_STATUS;
DECL|TERM_FORCED|enumerator|TERM_FORCED = 0x0010,
DECL|TERM_SATISFIED|enumerator|TERM_SATISFIED = 0x0020,
DECL|TERM_TMO|enumerator|TERM_TMO = 0x0040,
DECL|TERM_XXX|enumerator|TERM_XXX = TERM_FORCED | TERM_SATISFIED | TERM_TMO
DECL|Time|member|} Time;
DECL|XFER_B2R|enumerator|XFER_B2R,
DECL|XFER_BUSY|enumerator|XFER_BUSY = 0x0002,
DECL|XFER_IDLE|enumerator|XFER_IDLE = 0x0001,
DECL|XFER_TYPE|typedef|} XFER_TYPE;
DECL|XFER_UNDEFINED|enumerator|XFER_UNDEFINED,
DECL|XFER_W2B|enumerator|XFER_W2B,
DECL|XFER_W2R|enumerator|XFER_W2R
DECL|_K_SVC_BLOCK_WAITERS_GET|macro|_K_SVC_BLOCK_WAITERS_GET
DECL|_K_SVC_DEFRAG|macro|_K_SVC_DEFRAG
DECL|_K_SVC_EVENT_HANDLER_SET|macro|_K_SVC_EVENT_HANDLER_SET
DECL|_K_SVC_EVENT_SIGNAL|macro|_K_SVC_EVENT_SIGNAL
DECL|_K_SVC_EVENT_TEST_TIMEOUT|macro|_K_SVC_EVENT_TEST_TIMEOUT
DECL|_K_SVC_EVENT_TEST|macro|_K_SVC_EVENT_TEST
DECL|_K_SVC_FIFO_DEQUE_REPLY_TIMEOUT|macro|_K_SVC_FIFO_DEQUE_REPLY_TIMEOUT
DECL|_K_SVC_FIFO_DEQUE_REPLY|macro|_K_SVC_FIFO_DEQUE_REPLY
DECL|_K_SVC_FIFO_DEQUE_REQUEST|macro|_K_SVC_FIFO_DEQUE_REQUEST
DECL|_K_SVC_FIFO_ENQUE_REPLY_TIMEOUT|macro|_K_SVC_FIFO_ENQUE_REPLY_TIMEOUT
DECL|_K_SVC_FIFO_ENQUE_REPLY|macro|_K_SVC_FIFO_ENQUE_REPLY
DECL|_K_SVC_FIFO_ENQUE_REQUEST|macro|_K_SVC_FIFO_ENQUE_REQUEST
DECL|_K_SVC_FIFO_IOCTL|macro|_K_SVC_FIFO_IOCTL
DECL|_K_SVC_MBOX_RECEIVE_ACK|macro|_K_SVC_MBOX_RECEIVE_ACK
DECL|_K_SVC_MBOX_RECEIVE_DATA|macro|_K_SVC_MBOX_RECEIVE_DATA
DECL|_K_SVC_MBOX_RECEIVE_REPLY|macro|_K_SVC_MBOX_RECEIVE_REPLY
DECL|_K_SVC_MBOX_RECEIVE_REQUEST|macro|_K_SVC_MBOX_RECEIVE_REQUEST
DECL|_K_SVC_MBOX_SEND_ACK|macro|_K_SVC_MBOX_SEND_ACK
DECL|_K_SVC_MBOX_SEND_DATA|macro|_K_SVC_MBOX_SEND_DATA
DECL|_K_SVC_MBOX_SEND_REPLY|macro|_K_SVC_MBOX_SEND_REPLY
DECL|_K_SVC_MBOX_SEND_REQUEST|macro|_K_SVC_MBOX_SEND_REQUEST
DECL|_K_SVC_MEM_MAP_ALLOC_TIMEOUT|macro|_K_SVC_MEM_MAP_ALLOC_TIMEOUT
DECL|_K_SVC_MEM_MAP_ALLOC|macro|_K_SVC_MEM_MAP_ALLOC
DECL|_K_SVC_MEM_MAP_DEALLOC|macro|_K_SVC_MEM_MAP_DEALLOC
DECL|_K_SVC_MEM_POOL_BLOCK_GET_TIMEOUT_HANDLE|macro|_K_SVC_MEM_POOL_BLOCK_GET_TIMEOUT_HANDLE
DECL|_K_SVC_MEM_POOL_BLOCK_GET|macro|_K_SVC_MEM_POOL_BLOCK_GET
DECL|_K_SVC_MEM_POOL_BLOCK_RELEASE|macro|_K_SVC_MEM_POOL_BLOCK_RELEASE
DECL|_K_SVC_MOVEDATA_REQ|macro|_K_SVC_MOVEDATA_REQ
DECL|_K_SVC_MUTEX_LOCK_REPLY_TIMEOUT|macro|_K_SVC_MUTEX_LOCK_REPLY_TIMEOUT
DECL|_K_SVC_MUTEX_LOCK_REPLY|macro|_K_SVC_MUTEX_LOCK_REPLY
DECL|_K_SVC_MUTEX_LOCK_REQUEST|macro|_K_SVC_MUTEX_LOCK_REQUEST
DECL|_K_SVC_MUTEX_UNLOCK|macro|_K_SVC_MUTEX_UNLOCK
DECL|_K_SVC_NOP|macro|_K_SVC_NOP
DECL|_K_SVC_OFFLOAD_TO_FIBER|macro|_K_SVC_OFFLOAD_TO_FIBER
DECL|_K_SVC_PIPE_GET_ACK|macro|_K_SVC_PIPE_GET_ACK
DECL|_K_SVC_PIPE_GET_REPLY|macro|_K_SVC_PIPE_GET_REPLY
DECL|_K_SVC_PIPE_GET_REQUEST|macro|_K_SVC_PIPE_GET_REQUEST
DECL|_K_SVC_PIPE_GET_TIMEOUT|macro|_K_SVC_PIPE_GET_TIMEOUT
DECL|_K_SVC_PIPE_MOVEDATA_ACK|macro|_K_SVC_PIPE_MOVEDATA_ACK
DECL|_K_SVC_PIPE_PUT_ACK|macro|_K_SVC_PIPE_PUT_ACK
DECL|_K_SVC_PIPE_PUT_REPLY|macro|_K_SVC_PIPE_PUT_REPLY
DECL|_K_SVC_PIPE_PUT_REQUEST|macro|_K_SVC_PIPE_PUT_REQUEST
DECL|_K_SVC_PIPE_PUT_TIMEOUT|macro|_K_SVC_PIPE_PUT_TIMEOUT
DECL|_K_SVC_SEM_GROUP_RESET|macro|_K_SVC_SEM_GROUP_RESET
DECL|_K_SVC_SEM_GROUP_SIGNAL|macro|_K_SVC_SEM_GROUP_SIGNAL
DECL|_K_SVC_SEM_GROUP_WAIT_ACCEPT|macro|_K_SVC_SEM_GROUP_WAIT_ACCEPT
DECL|_K_SVC_SEM_GROUP_WAIT_ANY|macro|_K_SVC_SEM_GROUP_WAIT_ANY
DECL|_K_SVC_SEM_GROUP_WAIT_CANCEL|macro|_K_SVC_SEM_GROUP_WAIT_CANCEL
DECL|_K_SVC_SEM_GROUP_WAIT_READY|macro|_K_SVC_SEM_GROUP_WAIT_READY
DECL|_K_SVC_SEM_GROUP_WAIT_REQUEST|macro|_K_SVC_SEM_GROUP_WAIT_REQUEST
DECL|_K_SVC_SEM_GROUP_WAIT_TIMEOUT|macro|_K_SVC_SEM_GROUP_WAIT_TIMEOUT
DECL|_K_SVC_SEM_GROUP_WAIT|macro|_K_SVC_SEM_GROUP_WAIT
DECL|_K_SVC_SEM_INQUIRY|macro|_K_SVC_SEM_INQUIRY
DECL|_K_SVC_SEM_RESET|macro|_K_SVC_SEM_RESET
DECL|_K_SVC_SEM_SIGNAL|macro|_K_SVC_SEM_SIGNAL
DECL|_K_SVC_SEM_WAIT_REPLY_TIMEOUT|macro|_K_SVC_SEM_WAIT_REPLY_TIMEOUT
DECL|_K_SVC_SEM_WAIT_REPLY|macro|_K_SVC_SEM_WAIT_REPLY
DECL|_K_SVC_SEM_WAIT_REQUEST|macro|_K_SVC_SEM_WAIT_REQUEST
DECL|_K_SVC_TASK_GROUP_OP|macro|_K_SVC_TASK_GROUP_OP
DECL|_K_SVC_TASK_OP|macro|_K_SVC_TASK_OP
DECL|_K_SVC_TASK_PRIORITY_SET|macro|_K_SVC_TASK_PRIORITY_SET
DECL|_K_SVC_TASK_SLEEP|macro|_K_SVC_TASK_SLEEP
DECL|_K_SVC_TASK_WAKEUP|macro|_K_SVC_TASK_WAKEUP
DECL|_K_SVC_TASK_YIELD|macro|_K_SVC_TASK_YIELD
DECL|_K_SVC_TIMER_ALLOC|macro|_K_SVC_TIMER_ALLOC
DECL|_K_SVC_TIMER_DEALLOC|macro|_K_SVC_TIMER_DEALLOC
DECL|_K_SVC_TIMER_START|macro|_K_SVC_TIMER_START
DECL|_K_SVC_TIMER_STOP|macro|_K_SVC_TIMER_STOP
DECL|_K_SVC_UNDEFINED|macro|_K_SVC_UNDEFINED
DECL|_K_SVC_WORKLOAD_GET|macro|_K_SVC_WORKLOAD_GET
DECL|_MICRO_PRIVATE_TYPES_H|macro|_MICRO_PRIVATE_TYPES_H
DECL|__next|member|struct k_timer *__next;
DECL|__next|member|struct pool_struct *__next;
DECL|__prev|member|struct k_timer *__prev;
DECL|_a1arg|struct|struct _a1arg {
DECL|_c1arg|struct|struct _c1arg {
DECL|_e1arg|struct|struct _e1arg {
DECL|_g1arg|struct|struct _g1arg {
DECL|_l1arg|struct|struct _l1arg {
DECL|_m1arg|struct|struct _m1arg {
DECL|_p1arg|struct|struct _p1arg {
DECL|_pipe_ack_arg|struct|struct _pipe_ack_arg {
DECL|_pipe_req_arg|struct|struct _pipe_req_arg {
DECL|_pipe_xfer_ack_arg|struct|struct _pipe_xfer_ack_arg {
DECL|_pipe_xfer_req_arg|struct|struct _pipe_xfer_req_arg {
DECL|_q1arg|struct|struct _q1arg {
DECL|_q2arg|struct|struct _q2arg {
DECL|_s1arg|struct|struct _s1arg {
DECL|_u1arg|struct|struct _u1arg {
DECL|a1|member|struct _a1arg a1;
DECL|action|member|MovedAction action;
DECL|alloc|member|bool alloc;
DECL|argp|member|void *argp;
DECL|args|member|K_ARGS_ARGS args;
DECL|args|member|struct k_args *args;
DECL|args|member|struct k_args *args;
DECL|async_req|struct|struct async_req {
DECL|async|member|struct async_req async;
DECL|async|member|struct async_req async;
DECL|block_size|member|int block_size;
DECL|block_stat|struct|struct block_stat {
DECL|blocktable|member|struct block_stat *blocktable;
DECL|block|member|struct k_block block;
DECL|bufblock|member|char *bufblock;
DECL|c1|member|struct _c1arg c1;
DECL|continuation_receive|member|struct k_args *continuation_receive;
DECL|continuation_send|member|struct k_args *continuation_send;
DECL|count|member|int count;
DECL|data_ptr|member|void *data_ptr;
DECL|data_ptr|member|void *data_ptr; /* if NULL, data is embedded in cmd packet */
DECL|data|member|char *data;
DECL|data|member|char data[OCTET_TO_SIZEOFUNIT(40)];
DECL|destination|member|void *destination;
DECL|dummy|member|int dummy;
DECL|dummy|member|struct sync_req dummy;
DECL|dummy|member|uint32_t dummy;
DECL|duration|member|int32_t duration;
DECL|e1|member|struct _e1arg e1;
DECL|event|member|kevent_t event;
DECL|extra|member|} extra;
DECL|frag_tab|member|struct pool_block *frag_tab;
DECL|func|member|int (*func)();
DECL|func|member|kevent_handler_t func;
DECL|g1|member|struct _g1arg g1;
DECL|group|member|ktask_group_t group;
DECL|head|member|struct k_args **head;
DECL|head|member|struct k_task *head;
DECL|id|member|int id; /* if it is a Xfer to/from a buffer, this is the registered
DECL|id|member|kpipe_t id;
DECL|k_args_args|union|union k_args_args {
DECL|k_args|struct|struct k_args {
DECL|k_timer|struct|struct k_timer {
DECL|k_tqhd|struct|struct k_tqhd {
DECL|l1|member|struct _l1arg l1;
DECL|list|member|ksemg_t list;
DECL|m1|member|struct _m1arg m1;
DECL|maxblock_size|member|int maxblock_size;
DECL|mem_blocks|member|char *mem_blocks;
DECL|mem_status|member|uint32_t mem_status;
DECL|mess|member|struct k_msg mess;
DECL|minblock_size|member|int minblock_size;
DECL|mmap|member|kmemory_map_t mmap;
DECL|moved_req_args_setup|struct|struct moved_req_args_setup {
DECL|moved_req|member|struct moved_req moved_req;
DECL|moved_req|struct|struct moved_req {
DECL|mptr|member|void **mptr;
DECL|mutex|member|kmutex_t mutex;
DECL|next|member|struct k_args *next;
DECL|next|member|struct k_timer *next;
DECL|nr_of_entries|member|int nr_of_entries;
DECL|nr_of_frags|member|int nr_of_frags;
DECL|nr_of_maxblocks|member|int nr_of_maxblocks;
DECL|nsem|member|int nsem;
DECL|num_pending_xfers|member|int num_pending_xfers; /* # data Xfers (still) in progress */
DECL|opt|member|int opt;
DECL|opt|member|int opt;
DECL|p1|member|struct _p1arg p1;
DECL|params|member|int params;
DECL|period|member|int32_t period;
DECL|pipe_ack|member|struct _pipe_ack_arg pipe_ack;
DECL|pipe_ptr|member|struct _k_pipe_struct *pipe_ptr;
DECL|pipe_req|member|struct _pipe_req_arg pipe_req;
DECL|pipe_xfer_ack|member|struct _pipe_xfer_ack_arg pipe_xfer_ack;
DECL|pipe_xfer_req|member|struct _pipe_xfer_req_arg pipe_xfer_req;
DECL|pipe|member|} pipe;
DECL|pool_block|struct|struct pool_block {
DECL|pool_id|member|kmemory_pool_t pool_id;
DECL|pool_struct|struct|struct pool_struct {
DECL|prev|member|struct k_timer *prev;
DECL|priority|member|kpriority_t priority;
DECL|prio|member|kpriority_t prio;
DECL|ptr|member|struct _k_pipe_struct *ptr;
DECL|q1|member|struct _q1arg q1;
DECL|q2|member|struct _q2arg q2;
DECL|queue|member|kfifo_t queue;
DECL|queue|member|kfifo_t queue;
DECL|rcode|member|int rcode;
DECL|reader_ptr|member|struct k_args *reader_ptr; /* if there's a reader involved,
DECL|rep_dataptr|member|void *rep_dataptr;
DECL|rep_poolptr|member|void *rep_poolptr;
DECL|req_info|member|struct req_info req_info;
DECL|req_info|member|struct req_info req_info;
DECL|req_info|member|struct req_info req_info;
DECL|req_info|struct|struct req_info {
DECL|req_size|member|int req_size;
DECL|req_type|member|} req_type;
DECL|req_type|member|} req_type;
DECL|rval|member|int rval;
DECL|s1|member|struct _s1arg s1;
DECL|sema|member|ksem_t sema;
DECL|sema|member|ksem_t sema;
DECL|sema|member|ksem_t sema;
DECL|sema|member|ksem_t sema;
DECL|setup|member|struct moved_req_args_setup setup;
DECL|size|member|int size;
DECL|size|member|int size;
DECL|size|member|int size; /* amount of data Xferred */
DECL|source|member|void *source;
DECL|status|member|PIPE_REQUEST_STATUS status; /* status of processing of request */
DECL|sync_req|struct|struct sync_req {
DECL|sync|member|struct sync_req sync;
DECL|tail|member|struct k_task *tail;
DECL|task_id|member|ktask_t task_id;
DECL|task|member|ktask_t task;
DECL|task|member|ktask_t task;
DECL|task|member|ktask_t task;
DECL|task|member|struct k_task *task;
DECL|ticks|member|int32_t ticks;
DECL|time1|member|int64_t time1;
DECL|time2|member|int64_t time2;
DECL|timer|member|struct k_timer *timer;
DECL|timer|member|struct k_timer *timer;
DECL|total_size|member|int total_size;
DECL|total_size|member|int total_size;
DECL|total_size|member|int total_size; /* total size of data/free space */
DECL|total_size|member|uint32_t total_size;
DECL|u1|member|struct _u1arg u1;
DECL|val|member|int val;
DECL|waiters|member|struct k_args *waiters;
DECL|writer_ptr|member|struct k_args *writer_ptr; /* if there's a writer involved,
DECL|xfer_type|member|XFER_TYPE xfer_type; /* W2B, B2R or W2R */
DECL|xferred_size|member|int xferred_size;
DECL|xferred_size|member|int xferred_size; /* size of data ALREADY Xferred */
